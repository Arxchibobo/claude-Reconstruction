# AI 工作流洞察库

> **用途**: Claude Code 高效工作的方法论集合

---

## 核心洞察

### 1. 外部文件作为扩展记忆

**问题**: AI 上下文窗口有限，长任务容易遗忘初始目标。

**解决方案**: 三文件模式

```
task_plan.md     - 任务规划和进度追踪
notes.md         - 研究笔记和发现记录
[deliverable].md - 最终产出物
```

**关键机制**:
- 每个重要决策点前**重新读取 task_plan.md**
- 刷新注意力窗口，防止目标漂移
- 将思考过程外化，便于回溯

**使用场景**:
- 超过 10 步的任务
- 需要多次迭代的工作
- 涉及复杂决策的项目

---

### 2. 阶段门控（Phase Gating）

**问题**: AI 可能在未完全理解需求时就开始执行。

**解决方案**: 关键决策点等待用户确认

```
Phase 1: 需求理解 → [用户确认 "ready"]
           ↓
Phase 2: 设计方案 → [用户确认 "proceed"]
           ↓
Phase 3: 实现代码 → [自动执行]
           ↓
Phase 4: 验收报告 → [用户确认 "done"]
```

**原则**: 永远不进入下一阶段，直到用户明确确认。

---

### 3. 失败追踪（Failure Tracking）

**问题**: 同样的错误可能重复发生。

**解决方案**: 结构化记录错误

```markdown
## Errors Encountered

### [时间] 错误类型
**Error**: 具体错误信息
**Root Cause**: 根本原因
**Solution**: 解决方案
**Learning**: 经验教训
```

**价值**:
- 避免重复错误
- 积累领域知识
- 持续改进工作流

---

### 4. 自检清单（Self-Check Lists）

**问题**: 常见错误模式重复出现。

**解决方案**: 编码前使用自检清单

```markdown
### 异步操作自检
- [ ] 多个独立异步操作是否并行？
- [ ] 轮询是否设置超时？
- [ ] 是否有取消机制？

### 错误处理自检
- [ ] catch 块是否重新抛出错误？
- [ ] 所有退出路径是否清理资源？
```

**效果**: 预防胜于治疗

---

### 5. 渐进式细化（Progressive Refinement）

**问题**: 一次性生成完美代码很难。

**解决方案**: 分层次迭代

```
Layer 1: 骨架代码（结构正确）
    ↓
Layer 2: 核心逻辑（功能正确）
    ↓
Layer 3: 错误处理（健壮性）
    ↓
Layer 4: 优化细节（性能、可读性）
```

**好处**:
- 每层都可验证
- 问题定位更精准
- 减少返工

---

## 高级技巧

### 技巧 1: 并行探索

当不确定最佳方案时，同时探索多个方向：

```
方案 A: 使用 Redis 缓存
├─ 优点: 性能好、持久化
├─ 缺点: 额外依赖
└─ 适用: 分布式系统

方案 B: 内存缓存
├─ 优点: 简单、无依赖
├─ 缺点: 重启丢失、不共享
└─ 适用: 单机应用

推荐: 根据 [具体条件] 选择方案 [A/B]
```

### 技巧 2: 上下文压缩

长对话中定期总结关键信息：

```markdown
## 当前状态摘要

### 已完成
- 用户模型设计 ✓
- API 基础框架 ✓

### 进行中
- 认证逻辑实现

### 待完成
- 测试用例
- 文档更新

### 关键决策
- 使用 JWT 而非 Session
- 密码使用 bcrypt 加密
```

### 技巧 3: 假设验证

做出假设时明确标记，并在适当时机验证：

```markdown
## 假设列表

| # | 假设 | 状态 | 验证结果 |
|---|-----|------|---------|
| 1 | 数据库支持 JSON 类型 | 已验证 | ✓ PostgreSQL 支持 |
| 2 | API 响应时间 < 200ms | 待验证 | - |
| 3 | 用户量级 < 10000 | 需确认 | 询问用户 |
```

### 技巧 4: 模式识别

识别任务的类型，应用相应的解决模式：

| 任务类型 | 识别特征 | 推荐模式 |
|---------|---------|---------|
| CRUD | 数据增删改查 | 标准 REST 模式 |
| 集成 | 连接第三方服务 | 适配器模式 |
| 转换 | 数据格式转换 | 管道模式 |
| 调度 | 定时任务 | 队列模式 |
| 认证 | 用户身份验证 | JWT/Session 模式 |

---

## 反模式警示

### 反模式 1: 过早优化

```
❌ 错误: 一开始就考虑缓存、分片、CDN
✅ 正确: 先让功能正确运行，再按需优化
```

### 反模式 2: 假设用户意图

```
❌ 错误: 假设用户想要某种实现方式
✅ 正确: 遇到歧义时提问澄清
```

### 反模式 3: 忽略现有代码

```
❌ 错误: 用自己偏好的风格写新代码
✅ 正确: 遵循项目现有的代码风格和模式
```

### 反模式 4: 一次性大变更

```
❌ 错误: 修改 20 个文件然后一起提交
✅ 正确: 小步迭代，每步都可验证
```

---

## 效率提升

### 1. 工具选择启发式

```
需要外部数据？ → MCP
需要自动化？   → Skills
需要专业建议？ → Plugins
```

### 2. 并行执行

多个独立任务同时进行：

```javascript
// 并行读取多个文件
const [config, schema, data] = await Promise.all([
  readFile('config.json'),
  readFile('schema.sql'),
  readFile('data.csv')
]);
```

### 3. 模板复用

常见场景使用模板：

```markdown
## API 端点模板

### [METHOD] /api/[resource]

**请求**:
```json
{
  "field": "value"
}
```

**响应**:
```json
{
  "success": true,
  "data": {}
}
```

**错误**:
- 400: 参数错误
- 401: 未认证
- 500: 服务器错误
```

---

## 持续改进

### 会话结束复盘

```markdown
## 本次会话复盘

### 做得好的
- 使用了并行查询
- 提前识别了风险点

### 待改进
- SQL 查询可以更优化
- 错误处理可以更完善

### 新增知识点
- 学到了 CTE 的使用
- 了解了 honeycomb 查询语法

### 更新错题集
- 添加了 [新错误模式]
```

### 知识沉淀

```
发现新错误模式 → 记录到 ERROR_CATALOG
学到新技巧 → 记录到 AI_WORKFLOW_INSIGHTS
优化工作流 → 更新 DECISION_TREE
```
